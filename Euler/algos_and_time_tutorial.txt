Algorithms and Time Complexity: Keeping Code Efficient

"Algorithm."

As I say the word I can feel my brain getting emptier.
The word itself is like a blackhole of understanding. Thinking about it makes it more nebulous.
What does it MEAN? 

At its most basic, an algorithm is just a set of instructions for carrying out a specific task. From your washing machine
to the most secure networks in the world, algorithms help us do things well.  Need to find the shortest distance between
two points? <https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>.  Amazed by Google's ability to find that perfect
webpage for your search? <https://en.wikipedia.org/wiki/PageRank>.  Surprised no one has stolen everyone's personal data? 
<https://en.wikipedia.org/wiki/SHA-1>. 

Ok, I hear you...big deal right? Algorithms /do/ things. But how? What gives them these powers? Let's check back in with our
washing machine.

To wash clothes, washer machine doesn't have a single 'wash' step that magically does everything
(though that would be pretty cool). Instead, the engineer that made that washing machine had to think, 
"Hmm...if I want to wash something, what exactly does that mean? What are the steps that make up 'washing'?
How do I build something that can implement all these steps in the best order?" We know a few things about 
washing clothes: 1) We need some amount of water, 2) We need soap; 3) We need agitation; 
4) The clothes need to be rinsed. 

Understanding that we can break the mega-task "wash" into at least 4 smaller actions is a crucial step in understanding our use of algorithms.

As a programmer(engineer!), it is our job to tinker with these steps, and find not only /a/ way to code out the steps, but the /best/ way. The product of this tinkering is called an algorithm.

In this article, we will discuss:

-Modeling and Pseudocode
-Finding the /best/ algorithm
-Big O notation
-Problem solving: algorithms in motion
-Applying these skills to Euler No.1


#read the problem, analyze the problem, write a “just works” solution, iterate over solution until desired time complexity is achieved#



